initSidebarItems({"fn":[["f32x4_abs","Calculates the absolute value of each lane of a 128-bit vector interpreted as four 32-bit floating point numbers."],["f32x4_add","Adds pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_const","Materializes a constant SIMD value from the immediate operands."],["f32x4_convert_i32x4_s","Converts a 128-bit vector interpreted as four 32-bit signed integers into a 128-bit vector of four 32-bit floating point numbers."],["f32x4_convert_i32x4_u","Converts a 128-bit vector interpreted as four 32-bit unsigned integers into a 128-bit vector of four 32-bit floating point numbers."],["f32x4_div","Divides pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_eq","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_extract_lane","Extracts a lane from a 128-bit vector interpreted as 4 packed f32 numbers."],["f32x4_ge","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_gt","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_le","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_lt","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_max","Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_min","Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_mul","Multiplies pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_ne","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_neg","Negates each lane of a 128-bit vector interpreted as four 32-bit floating point numbers."],["f32x4_replace_lane","Replaces a lane from a 128-bit vector interpreted as 4 packed f32 numbers."],["f32x4_splat","Creates a vector with identical lanes."],["f32x4_sqrt","Calculates the square root of each lane of a 128-bit vector interpreted as four 32-bit floating point numbers."],["f32x4_sub","Subtracts pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f64x2_abs","Calculates the absolute value of each lane of a 128-bit vector interpreted as two 64-bit floating point numbers."],["f64x2_add","Adds pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_const","Materializes a constant SIMD value from the immediate operands."],["f64x2_div","Divides pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_eq","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_extract_lane","Extracts a lane from a 128-bit vector interpreted as 2 packed f64 numbers."],["f64x2_ge","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_gt","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_le","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_lt","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_max","Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_min","Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_mul","Multiplies pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_ne","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_neg","Negates each lane of a 128-bit vector interpreted as two 64-bit floating point numbers."],["f64x2_replace_lane","Replaces a lane from a 128-bit vector interpreted as 2 packed f64 numbers."],["f64x2_splat","Creates a vector with identical lanes."],["f64x2_sqrt","Calculates the square root of each lane of a 128-bit vector interpreted as two 64-bit floating point numbers."],["f64x2_sub","Subtracts pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["i16x8_abs","Lane-wise wrapping absolute value."],["i16x8_add","Adds two 128-bit vectors as if they were two packed eight 16-bit integers."],["i16x8_add_saturate_s","Adds two 128-bit vectors as if they were two packed eight 16-bit signed integers, saturating on overflow to `i16::MAX`."],["i16x8_add_saturate_u","Adds two 128-bit vectors as if they were two packed eight 16-bit unsigned integers, saturating on overflow to `u16::MAX`."],["i16x8_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i16x8_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i16x8_avgr_u","Lane-wise rounding average."],["i16x8_const","Materializes a constant SIMD value from the immediate operands."],["i16x8_eq","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit integers."],["i16x8_extract_lane","Extracts a lane from a 128-bit vector interpreted as 8 packed i16 numbers."],["i16x8_ge_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_ge_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_gt_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_gt_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_le_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_le_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_load8x8_s","Load eight 8-bit integers and sign extend each one to a 16-bit lane"],["i16x8_load8x8_u","Load eight 8-bit integers and zero extend each one to a 16-bit lane"],["i16x8_lt_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_lt_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_max_s","Compares lane-wise signed integers, and returns the maximum of each pair."],["i16x8_max_u","Compares lane-wise unsigned integers, and returns the maximum of each pair."],["i16x8_min_s","Compares lane-wise signed integers, and returns the minimum of each pair."],["i16x8_min_u","Compares lane-wise unsigned integers, and returns the minimum of each pair."],["i16x8_mul","Multiplies two 128-bit vectors as if they were two packed eight 16-bit signed integers."],["i16x8_narrow_i32x4_s","Converts two input vectors into a smaller lane vector by narrowing each lane."],["i16x8_narrow_i32x4_u","Converts two input vectors into a smaller lane vector by narrowing each lane."],["i16x8_ne","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit integers."],["i16x8_neg","Negates a 128-bit vectors intepreted as eight 16-bit signed integers"],["i16x8_replace_lane","Replaces a lane from a 128-bit vector interpreted as 8 packed i16 numbers."],["i16x8_shl","Shifts each lane to the left by the specified number of bits."],["i16x8_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i16x8_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i16x8_splat","Creates a vector with identical lanes."],["i16x8_sub","Subtracts two 128-bit vectors as if they were two packed eight 16-bit integers."],["i16x8_sub_saturate_s","Subtracts two 128-bit vectors as if they were two packed eight 16-bit signed integers, saturating on overflow to `i16::MIN`."],["i16x8_sub_saturate_u","Subtracts two 128-bit vectors as if they were two packed eight 16-bit unsigned integers, saturating on overflow to 0."],["i16x8_widen_high_i8x16_s","Converts high half of the smaller lane vector to a larger lane vector, sign extended."],["i16x8_widen_high_i8x16_u","Converts high half of the smaller lane vector to a larger lane vector, zero extended."],["i16x8_widen_low_i8x16_s","Converts low half of the smaller lane vector to a larger lane vector, sign extended."],["i16x8_widen_low_i8x16_u","Converts low half of the smaller lane vector to a larger lane vector, zero extended."],["i32x4_abs","Lane-wise wrapping absolute value."],["i32x4_add","Adds two 128-bit vectors as if they were two packed four 32-bit integers."],["i32x4_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i32x4_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i32x4_const","Materializes a constant SIMD value from the immediate operands."],["i32x4_eq","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit integers."],["i32x4_extract_lane","Extracts a lane from a 128-bit vector interpreted as 4 packed i32 numbers."],["i32x4_ge_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_ge_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_gt_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_gt_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_le_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_le_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_load16x4_s","Load four 16-bit integers and sign extend each one to a 32-bit lane"],["i32x4_load16x4_u","Load four 16-bit integers and zero extend each one to a 32-bit lane"],["i32x4_lt_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_lt_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_max_s","Compares lane-wise signed integers, and returns the maximum of each pair."],["i32x4_max_u","Compares lane-wise unsigned integers, and returns the maximum of each pair."],["i32x4_min_s","Compares lane-wise signed integers, and returns the minimum of each pair."],["i32x4_min_u","Compares lane-wise unsigned integers, and returns the minimum of each pair."],["i32x4_mul","Multiplies two 128-bit vectors as if they were two packed four 32-bit signed integers."],["i32x4_ne","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit integers."],["i32x4_neg","Negates a 128-bit vectors intepreted as four 32-bit signed integers"],["i32x4_replace_lane","Replaces a lane from a 128-bit vector interpreted as 4 packed i32 numbers."],["i32x4_shl","Shifts each lane to the left by the specified number of bits."],["i32x4_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i32x4_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i32x4_splat","Creates a vector with identical lanes."],["i32x4_sub","Subtracts two 128-bit vectors as if they were two packed four 32-bit integers."],["i32x4_trunc_sat_f32x4_s","Converts a 128-bit vector interpreted as four 32-bit floating point numbers into a 128-bit vector of four 32-bit signed integers."],["i32x4_trunc_sat_f32x4_u","Converts a 128-bit vector interpreted as four 32-bit floating point numbers into a 128-bit vector of four 32-bit unsigned integers."],["i32x4_widen_high_i16x8_s","Converts high half of the smaller lane vector to a larger lane vector, sign extended."],["i32x4_widen_high_i16x8_u","Converts high half of the smaller lane vector to a larger lane vector, zero extended."],["i32x4_widen_low_i16x8_s","Converts low half of the smaller lane vector to a larger lane vector, sign extended."],["i32x4_widen_low_i16x8_u","Converts low half of the smaller lane vector to a larger lane vector, zero extended."],["i64x2_add","Adds two 128-bit vectors as if they were two packed two 64-bit integers."],["i64x2_const","Materializes a constant SIMD value from the immediate operands."],["i64x2_extract_lane","Extracts a lane from a 128-bit vector interpreted as 2 packed i64 numbers."],["i64x2_load32x2_s","Load two 32-bit integers and sign extend each one to a 64-bit lane"],["i64x2_load32x2_u","Load two 32-bit integers and zero extend each one to a 64-bit lane"],["i64x2_mul","Multiplies two 128-bit vectors as if they were two packed two 64-bit integers."],["i64x2_neg","Negates a 128-bit vectors intepreted as two 64-bit signed integers"],["i64x2_replace_lane","Replaces a lane from a 128-bit vector interpreted as 2 packed i64 numbers."],["i64x2_shl","Shifts each lane to the left by the specified number of bits."],["i64x2_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i64x2_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i64x2_splat","Creates a vector with identical lanes."],["i64x2_sub","Subtracts two 128-bit vectors as if they were two packed two 64-bit integers."],["i8x16_abs","Lane-wise wrapping absolute value."],["i8x16_add","Adds two 128-bit vectors as if they were two packed sixteen 8-bit integers."],["i8x16_add_saturate_s","Adds two 128-bit vectors as if they were two packed sixteen 8-bit signed integers, saturating on overflow to `i8::MAX`."],["i8x16_add_saturate_u","Adds two 128-bit vectors as if they were two packed sixteen 8-bit unsigned integers, saturating on overflow to `u8::MAX`."],["i8x16_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i8x16_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i8x16_avgr_u","Lane-wise rounding average."],["i8x16_const","Materializes a constant SIMD value from the immediate operands."],["i8x16_eq","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit integers."],["i8x16_extract_lane","Extracts a lane from a 128-bit vector interpreted as 16 packed i8 numbers."],["i8x16_ge_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_ge_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_gt_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_gt_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_le_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_le_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_lt_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_lt_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_max_s","Compares lane-wise signed integers, and returns the maximum of each pair."],["i8x16_max_u","Compares lane-wise unsigned integers, and returns the maximum of each pair."],["i8x16_min_s","Compares lane-wise signed integers, and returns the minimum of each pair."],["i8x16_min_u","Compares lane-wise unsigned integers, and returns the minimum of each pair."],["i8x16_narrow_i16x8_s","Converts two input vectors into a smaller lane vector by narrowing each lane."],["i8x16_narrow_i16x8_u","Converts two input vectors into a smaller lane vector by narrowing each lane."],["i8x16_ne","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit integers."],["i8x16_neg","Negates a 128-bit vectors intepreted as sixteen 8-bit signed integers"],["i8x16_replace_lane","Replaces a lane from a 128-bit vector interpreted as 16 packed i8 numbers."],["i8x16_shl","Shifts each lane to the left by the specified number of bits."],["i8x16_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i8x16_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i8x16_splat","Creates a vector with identical lanes."],["i8x16_sub","Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit integers."],["i8x16_sub_saturate_s","Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit signed integers, saturating on overflow to `i8::MIN`."],["i8x16_sub_saturate_u","Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit unsigned integers, saturating on overflow to 0."],["memory_atomic_notify","Corresponding intrinsic to wasm’s `memory.atomic.notify` instruction"],["memory_atomic_wait32","Corresponding intrinsic to wasm’s `memory.atomic.wait32` instruction"],["memory_atomic_wait64","Corresponding intrinsic to wasm’s `memory.atomic.wait64` instruction"],["memory_grow","Corresponding intrinsic to wasm’s `memory.grow` instruction"],["memory_size","Corresponding intrinsic to wasm’s `memory.size` instruction"],["unreachable","Generates the trap instruction `UNREACHABLE`"],["v128_and","Performs a bitwise and of the two input 128-bit vectors, returning the resulting vector."],["v128_andnot","Bitwise AND of bits of `a` and the logical inverse of bits of `b`."],["v128_bitselect","Use the bitmask in `c` to select bits from `v1` when 1 and `v2` when 0."],["v128_load","Loads a `v128` vector from the given heap address."],["v128_not","Flips each bit of the 128-bit input vector."],["v128_or","Performs a bitwise or of the two input 128-bit vectors, returning the resulting vector."],["v128_store","Stores a `v128` vector to the given heap address."],["v128_xor","Performs a bitwise xor of the two input 128-bit vectors, returning the resulting vector."],["v16x8_load_splat","Load a single element and splat to all lanes of a v128 vector."],["v16x8_shuffle","Same as [`v8x16_shuffle`], except operates as if the inputs were eight 16-bit integers, only taking 8 indices to shuffle."],["v32x4_load_splat","Load a single element and splat to all lanes of a v128 vector."],["v32x4_shuffle","Same as [`v8x16_shuffle`], except operates as if the inputs were four 32-bit integers, only taking 4 indices to shuffle."],["v64x2_load_splat","Load a single element and splat to all lanes of a v128 vector."],["v64x2_shuffle","Same as [`v8x16_shuffle`], except operates as if the inputs were two 64-bit integers, only taking 2 indices to shuffle."],["v8x16_load_splat","Load a single element and splat to all lanes of a v128 vector."],["v8x16_shuffle","Returns a new vector with lanes selected from the lanes of the two input vectors `$a` and `$b` specified in the 16 immediate operands."],["v8x16_swizzle","Returns a new vector with lanes selected from the lanes of the first input vector `a` specified in the second input vector `s`."]],"struct":[["v128","WASM-specific 128-bit wide SIMD vector type."]]});